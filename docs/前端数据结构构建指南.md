# 前端数据结构构建指南

本文档说明如何在前端构建点、线、面的 GeoJSON 数据结构，并调用后端 API 进行 CRUD 操作。

---

## 一、数据结构规范

所有数据必须遵循 **GeoJSON Feature** 格式，这是调用 API 的标准格式。

### 1.1 点（Point）数据结构

```javascript
const pointFeature = {
    type: "Feature",
    properties: {
        name: "村庄名称",           // 必需：要素名称
        osm_id: "4510863998",      // 可选：OSM ID
        code: 1003,                // 可选：分类代码
        fclass: "village",         // 可选：要素类别
        population: 0              // 可选：人口数
        // 可以添加其他自定义属性
    },
    geometry: {
        type: "Point",
        coordinates: [111.0686353, 35.1284125]  // [经度, 纬度] - WGS84坐标系
    }
};
```

**关键点：**
- `coordinates` 是数组 `[lon, lat]`，**经度在前，纬度在后**
- 坐标系必须是 **WGS84 (EPSG:4326)**
- `properties.name` 是必需字段（用于查询和显示）

---

### 1.2 线（LineString / MultiLineString）数据结构

#### 单线（LineString）

```javascript
const lineFeature = {
    type: "Feature",
    properties: {
        name: "河渠名称"  // 必需：河渠名称
        // 可以添加其他自定义属性
    },
    geometry: {
        type: "LineString",
        coordinates: [
            [111.1636033, 35.2039341],  // 起点 [经度, 纬度]
            [111.1636847, 35.2039457],  // 中间点
            [111.1639466, 35.2039862],  // ...
            [111.1643465, 35.2040325]   // 终点
        ]
    }
};
```

#### 多线（MultiLineString）

```javascript
const multiLineFeature = {
    type: "Feature",
    properties: {
        name: "引黄灌溉渠"
    },
    geometry: {
        type: "MultiLineString",
        coordinates: [
            // 第一条线
            [
                [110.9649774, 35.0819862],
                [110.9627356, 35.0809037],
                [110.9622181, 35.0806498]
            ],
            // 第二条线
            [
                [111.0899224, 35.1774968],
                [111.0893847, 35.1773524],
                [111.0882327, 35.1771079]
            ]
        ]
    }
};
```

**关键点：**
- `LineString`: `coordinates` 是二维数组 `[[lon, lat], ...]`
- `MultiLineString`: `coordinates` 是三维数组 `[[[lon, lat], ...], ...]`
- 每条线至少需要 2 个点

---

### 1.3 面（Polygon / MultiPolygon）数据结构

#### 单面（Polygon）

```javascript
const polygonFeature = {
    type: "Feature",
    properties: {
        name: "安邑水库",           // 必需：水系名称
        osm_id: "255803254",       // 可选
        code: 8201,                // 可选：分类代码
        fclass: "reservoir"        // 可选：要素类别（reservoir=水库, water=水体）
    },
    geometry: {
        type: "Polygon",
        coordinates: [
            // 外环（必须闭合：第一个点和最后一个点相同）
            [
                [111.0258311, 35.0559758],  // 起点
                [111.0264874, 35.0554562],
                [111.0266415, 35.0550981],
                // ... 更多点
                [111.0258311, 35.0559758]   // 终点（与起点相同，闭合）
            ]
            // 如果有内环（洞），可以添加更多数组
        ]
    }
};
```

#### 多面（MultiPolygon）

```javascript
const multiPolygonFeature = {
    type: "Feature",
    properties: {
        name: "复合水系"
    },
    geometry: {
        type: "MultiPolygon",
        coordinates: [
            // 第一个面
            [
                [
                    [111.0258311, 35.0559758],
                    [111.0264874, 35.0554562],
                    [111.0258311, 35.0559758]  // 闭合
                ]
            ],
            // 第二个面
            [
                [
                    [111.0297132, 35.0515044],
                    [111.0300961, 35.0508469],
                    [111.0297132, 35.0515044]  // 闭合
                ]
            ]
        ]
    }
};
```

**关键点：**
- `Polygon`: `coordinates` 是三维数组 `[[[lon, lat], ...]]`
- 外环必须**闭合**（第一个点和最后一个点相同）
- 可以有内环（洞），内环也是闭合的环
- `MultiPolygon`: `coordinates` 是四维数组 `[[[[lon, lat], ...]]]`

---

## 二、从 Leaflet 图层提取数据

如果你使用 Leaflet 绘制工具（如 `L.Draw`）绘制了要素，需要转换为 GeoJSON Feature：

### 2.1 从 Leaflet 绘制工具提取

```javascript
// 假设你使用了 Leaflet Draw 插件
map.on('draw:created', function (e) {
    const layer = e.layer;
    const feature = layer.toGeoJSON();  // Leaflet 自动转换为 GeoJSON
    
    // feature 已经是标准的 GeoJSON Feature
    // 可以添加或修改 properties
    feature.properties = feature.properties || {};
    feature.properties.name = document.getElementById('name-input').value;
    
    // 调用 API 保存
    saveFeature(feature, 'water_bodies');  // 或 'villages', 'rivers'
});
```

### 2.2 从现有图层提取

```javascript
// 从 Leaflet GeoJSON 图层提取
const geoJsonLayer = L.geoJSON(geojsonData);
geoJsonLayer.eachLayer(function(layer) {
    const feature = layer.toGeoJSON();
    // 使用 feature
});

// 从 CircleMarker（点）提取
const marker = L.circleMarker([35.1284125, 111.0686353]);
const feature = {
    type: "Feature",
    properties: {
        name: "村庄名称"
    },
    geometry: {
        type: "Point",
        coordinates: [marker.getLatLng().lng, marker.getLatLng().lat]  // 注意顺序
    }
};
```

---

## 三、调用 API 接口

### 3.1 创建要素（POST）

```javascript
// 创建村庄（点）
async function createVillagePoint(name, lon, lat) {
    const feature = {
        type: "Feature",
        properties: {
            name: name
        },
        geometry: {
            type: "Point",
            coordinates: [lon, lat]
        }
    };
    
    try {
        const result = await createVillage(feature);
        console.log('创建成功，gid:', result.data.gid);
        return result;
    } catch (error) {
        console.error('创建失败:', error);
        throw error;
    }
}

// 创建河渠（线）
async function createRiverLine(name, coordinates) {
    const feature = {
        type: "Feature",
        properties: {
            name: name
        },
        geometry: {
            type: "LineString",
            coordinates: coordinates  // [[lon, lat], ...]
        }
    };
    
    try {
        const result = await createRiver(feature);
        console.log('创建成功，gid:', result.data.gid);
        return result;
    } catch (error) {
        console.error('创建失败:', error);
        throw error;
    }
}

// 创建水系（面）
async function createWaterBodyPolygon(name, coordinates) {
    const feature = {
        type: "Feature",
        properties: {
            name: name,
            fclass: "water"  // 或 "reservoir"
        },
        geometry: {
            type: "Polygon",
            coordinates: [coordinates]  // [[[lon, lat], ...]] - 注意是三维数组
        }
    };
    
    // 确保面闭合
    if (coordinates.length > 0) {
        const first = coordinates[0];
        const last = coordinates[coordinates.length - 1];
        if (first[0] !== last[0] || first[1] !== last[1]) {
            coordinates.push([first[0], first[1]]);  // 添加闭合点
        }
    }
    
    try {
        const result = await createWaterBody(feature);
        console.log('创建成功，gid:', result.data.gid);
        return result;
    } catch (error) {
        console.error('创建失败:', error);
        throw error;
    }
}
```

### 3.2 更新要素（PUT）

```javascript
// 更新村庄
async function updateVillagePoint(gid, name, lon, lat) {
    const feature = {
        type: "Feature",
        properties: {
            name: name,
            // 保留原有属性（如果需要）
        },
        geometry: {
            type: "Point",
            coordinates: [lon, lat]
        }
    };
    
    try {
        const result = await updateVillage(gid, feature);
        console.log('更新成功');
        return result;
    } catch (error) {
        console.error('更新失败:', error);
        throw error;
    }
}

// 更新水系（面）
async function updateWaterBodyPolygon(gid, name, coordinates) {
    const feature = {
        type: "Feature",
        properties: {
            name: name
        },
        geometry: {
            type: "Polygon",
            coordinates: [coordinates]
        }
    };
    
    // 确保面闭合
    if (coordinates.length > 0) {
        const first = coordinates[0];
        const last = coordinates[coordinates.length - 1];
        if (first[0] !== last[0] || first[1] !== last[1]) {
            coordinates.push([first[0], first[1]]);
        }
    }
    
    try {
        const result = await updateWaterBody(gid, feature);
        console.log('更新成功');
        return result;
    } catch (error) {
        console.error('更新失败:', error);
        throw error;
    }
}
```

### 3.3 删除要素（DELETE）

```javascript
// 删除村庄（软删除）
async function deleteVillagePoint(gid) {
    try {
        const result = await deleteVillage(gid);
        console.log('删除成功');
        return result;
    } catch (error) {
        console.error('删除失败:', error);
        throw error;
    }
}

// 删除水系
async function deleteWaterBodyPolygon(gid) {
    try {
        const result = await deleteWaterBody(gid);
        console.log('删除成功');
        return result;
    } catch (error) {
        console.error('删除失败:', error);
        throw error;
    }
}
```

---

## 四、完整示例：绘制面并保存

```javascript
// 使用 Leaflet Draw 绘制多边形并保存
let drawControl;
let drawnLayer;

// 初始化绘制工具
function initDrawTool() {
    drawnLayer = new L.FeatureGroup();
    map.addLayer(drawnLayer);
    
    drawControl = new L.Control.Draw({
        draw: {
            polygon: {
                allowIntersection: false,
                showArea: true
            },
            polyline: false,
            circle: false,
            rectangle: false,
            marker: false
        },
        edit: {
            featureGroup: drawnLayer
        }
    });
    
    map.addControl(drawControl);
    
    // 监听绘制完成事件
    map.on('draw:created', async function (e) {
        const layer = e.layer;
        const feature = layer.toGeoJSON();
        
        // 添加属性
        const name = prompt('请输入水系名称:');
        if (!name) {
            map.removeLayer(layer);
            return;
        }
        
        feature.properties = {
            name: name,
            fclass: "water"
        };
        
        // 确保面闭合
        const coords = feature.geometry.coordinates[0];
        if (coords.length > 0) {
            const first = coords[0];
            const last = coords[coords.length - 1];
            if (first[0] !== last[0] || first[1] !== last[1]) {
                coords.push([first[0], first[1]]);
            }
        }
        
        // 保存到数据库
        try {
            const result = await createWaterBody(feature);
            console.log('保存成功，gid:', result.data.gid);
            
            // 添加到地图
            drawnLayer.addLayer(layer);
            
            // 显示成功消息
            alert('水系创建成功！ID: ' + result.data.gid);
        } catch (error) {
            console.error('保存失败:', error);
            alert('保存失败: ' + error.message);
            map.removeLayer(layer);
        }
    });
}

// 页面加载后初始化
initDrawTool();
```

---

## 五、数据验证

在调用 API 前，建议进行数据验证：

```javascript
function validateFeature(feature, type) {
    // 检查基本结构
    if (!feature || feature.type !== 'Feature') {
        throw new Error('Invalid GeoJSON Feature');
    }
    
    if (!feature.geometry) {
        throw new Error('Missing geometry');
    }
    
    if (!feature.properties) {
        throw new Error('Missing properties');
    }
    
    // 检查几何类型
    const geomType = feature.geometry.type;
    if (type === 'point' && geomType !== 'Point') {
        throw new Error('Expected Point geometry');
    }
    if (type === 'line' && !['LineString', 'MultiLineString'].includes(geomType)) {
        throw new Error('Expected LineString or MultiLineString geometry');
    }
    if (type === 'polygon' && !['Polygon', 'MultiPolygon'].includes(geomType)) {
        throw new Error('Expected Polygon or MultiPolygon geometry');
    }
    
    // 检查坐标
    if (!feature.geometry.coordinates || feature.geometry.coordinates.length === 0) {
        throw new Error('Empty coordinates');
    }
    
    // 检查名称
    if (!feature.properties.name || feature.properties.name.trim() === '') {
        throw new Error('Name is required');
    }
    
    // 检查面是否闭合
    if (geomType === 'Polygon') {
        const coords = feature.geometry.coordinates[0];
        if (coords.length < 4) {  // 至少4个点（包括闭合点）
            throw new Error('Polygon must have at least 3 points');
        }
        const first = coords[0];
        const last = coords[coords.length - 1];
        if (first[0] !== last[0] || first[1] !== last[1]) {
            console.warn('Polygon is not closed, will be closed automatically');
            coords.push([first[0], first[1]]);
        }
    }
    
    return true;
}

// 使用示例
try {
    validateFeature(feature, 'polygon');
    await createWaterBody(feature);
} catch (error) {
    console.error('验证失败:', error);
}
```

---

## 六、常见问题

### Q1: 坐标顺序是什么？
**A:** GeoJSON 使用 `[经度, 纬度]`（lon, lat），与 Leaflet 的 `[纬度, 经度]`（lat, lon）相反。

```javascript
// Leaflet
const latlng = [35.1284125, 111.0686353];  // [lat, lon]

// GeoJSON
const coordinates = [111.0686353, 35.1284125];  // [lon, lat]
```

### Q2: 面必须闭合吗？
**A:** 是的，Polygon 的外环必须闭合（第一个点和最后一个点相同）。如果未闭合，后端会自动处理，但建议前端先闭合。

### Q3: 可以添加自定义属性吗？
**A:** 可以，`properties` 对象中可以添加任意字段，但 `name` 字段是必需的（用于查询）。

### Q4: 坐标系是什么？
**A:** 必须使用 **WGS84 (EPSG:4326)**，这是 GeoJSON 标准坐标系。

### Q5: 如何从地图上已有的要素提取数据？
**A:** 使用 `layer.toGeoJSON()` 方法：

```javascript
// GeoJSON 图层
geoJsonLayer.eachLayer(function(layer) {
    const feature = layer.toGeoJSON();
    // 使用 feature
});

// CircleMarker
const marker = L.circleMarker([lat, lon]);
const feature = {
    type: "Feature",
    properties: { name: "..." },
    geometry: {
        type: "Point",
        coordinates: [marker.getLatLng().lng, marker.getLatLng().lat]
    }
};
```

---

## 七、API 函数列表

所有 API 函数定义在 `output/js/api.js` 中：

### 村庄（点）
- `loadVillages()` - 获取所有村庄
- `getVillage(gid)` - 获取单个村庄
- `createVillage(feature)` - 创建村庄
- `updateVillage(gid, feature)` - 更新村庄
- `deleteVillage(gid)` - 删除村庄
- `searchVillagesByName(name)` - 按名称查询

### 河渠（线）
- `loadRivers()` - 获取所有河渠
- `createRiver(feature)` - 创建河渠
- `updateRiver(gid, feature)` - 更新河渠
- `deleteRiver(gid)` - 删除河渠
- `searchRiversByName(name)` - 按名称查询

### 水系（面）
- `loadWaterBodies()` - 获取所有水系
- `createWaterBody(feature)` - 创建水系
- `updateWaterBody(gid, feature)` - 更新水系
- `deleteWaterBody(gid)` - 删除水系
- `searchWaterBodiesByName(name)` - 按名称查询

---

## 八、完整工作流程示例

```javascript
// 1. 用户在地图上绘制多边形
map.on('draw:created', async function (e) {
    const layer = e.layer;
    let feature = layer.toGeoJSON();
    
    // 2. 获取用户输入的名称
    const name = prompt('请输入水系名称:');
    if (!name) {
        map.removeLayer(layer);
        return;
    }
    
    // 3. 设置属性
    feature.properties = {
        name: name,
        fclass: "water"
    };
    
    // 4. 验证数据
    try {
        validateFeature(feature, 'polygon');
    } catch (error) {
        alert('数据验证失败: ' + error.message);
        map.removeLayer(layer);
        return;
    }
    
    // 5. 调用 API 保存
    try {
        const result = await createWaterBody(feature);
        console.log('保存成功，gid:', result.data.gid);
        
        // 6. 更新 feature 的 gid（如果需要）
        feature.properties.gid = result.data.gid;
        feature.id = result.data.gid;
        
        // 7. 添加到地图并绑定事件
        const newLayer = L.geoJSON(feature, {
            style: {
                color: '#45b7d1',
                fillColor: '#45b7d1',
                fillOpacity: 0.3,
                weight: 2
            }
        }).addTo(map);
        
        // 绑定点击事件
        newLayer.on('click', function(e) {
            const popup = L.popup()
                .setContent(`<b>${feature.properties.name}</b><br>ID: ${result.data.gid}`)
                .setLatLng(e.latlng)
                .openOn(map);
        });
        
        alert('创建成功！ID: ' + result.data.gid);
    } catch (error) {
        console.error('保存失败:', error);
        alert('保存失败: ' + error.message);
        map.removeLayer(layer);
    }
});
```

---

## 总结

1. **数据结构**：必须遵循 GeoJSON Feature 格式
2. **坐标顺序**：`[经度, 纬度]`（与 Leaflet 相反）
3. **面闭合**：Polygon 必须闭合
4. **必需字段**：`properties.name` 是必需的
5. **坐标系**：WGS84 (EPSG:4326)
6. **API 调用**：使用 `api.js` 中定义的函数

遵循以上规范，即可成功在前端构建数据并调用后端 API 进行存储。

